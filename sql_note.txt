     Select单表查询语句：select……from……where……（1）查询student表中全部记录，要求列出全部字段select student.* from student语句中“*”表示所有字段。如果查询的内容来自于一个表，可以省略“表名.”，写作*,上边的语句可以写作：Select * from student。（2）从student表中查询学生全部记录，student_no,student_name,gender3列，并将显示结果的标题改为“学号”，“姓名”，“性别”，见图2-14select student.student_no as 学号,student.student_name as 姓名,student.gender as 性别 from student由于显示的字段来源于一个表student，故上述select语句也可写作：select student_no as 学号, student_name as 姓名, gender as 性别 from student（3）从student表中查询gender是“女”的记录，显示student_no ，student_name ，gender 3列，语句为： select student_no as 学号,student_name as 姓名,gender as 性别 from student where gender='女'本语句中“where”用于条件查询,多条件时用and（与条件） 或者or（或条件）连接。（4）从student表中查询姓“王”的学生，列出全部字段，语句为：select * from student where student_name like ”王%”语句中“%”表示统配符，表示多个字符，在有的语言如access中要写作“*”，下边语句完成与上边语句相同的功能：select * from student where substring(student_name,1,1)= '王'（5）如果student表中没有gender列，根据身份证号，判断学生的性别、年龄，显示“姓名”、“性别”，“年龄”（计算年龄只考虑年，不考虑月和日）3列select student_name as 姓名,iif(substring (identification,17,1)%2=0,'女','男') as 性别,year(getdate())-substring (identification,7,4) as 年龄 from studentGetdate()取出系统当前日期和时间，iif()用于条件判断，%是求余运算符。低版本的，改为：select student_name as 姓名,case when substring(identification,17,1)%2=0 then '女' else '男' end,year(getdate())-substring(identification,7,4) as 年龄 from student（6）查询学号是“41321059”或者“41340136”的全部记录select * from student where student_no in(‘41321059’, ‘41340136’)语句中使用“in”运算符。多个值之间要用“，”分开。也可以写作：select * from student where student_no='41321059' or student_no ='41340136'（7）查询学号在“41321059”到“41340136”间的记录select * from student where student_no between '41321059'  and '41340136'查询在某个范围，书写条件时，可以使用between…...and……。（8）列出score表中的课号select course_no as 课号 from score该语句执行后，由于一门课可以有多个学生学习，故出现许多重复的课号，要避免此种情况，使用语句：select distinct course_no as 课号 from scoredistinct过滤重复的记录。（9）查询第4到6条记录.SQL Server不支持limit select top (6-4+1) * from student where id not in(select top (4-1) id from student order by id ) order by id    排序语句：select……from ……where….order by…（1）查询student表中全部记录，且按姓名排序select * from student order by student_name可以看出不指明排序方式的情况下，是升序（按照汉字的拼音字母由a到z），这是默认排序方式，该语句相当于Select * from student order by gender asc。Asc的英文单词是ascend，是上升，但语句中只能写asc，不能写ascend。如果要按姓名降序排列，语句为：select * from student order by student_name descdesc表示descend（2）查询student表中全部记录，先按“gender”升序排序，然后再按“student_name”降序排序select * from student order by gender asc, student_name desc（3）从student表中随机挑选1条记录select top 1 * from student order by newID()newid()的返回一个uniqueidentifier（全局唯一的标识）值，top 1选取排序后的第1条记录。（4）从student表中查询女生记录，将查询结果输出到一个表文件result中select * into result from student where gender='女'        统计和分组语句：select……from ……where….group by…having…在某些情况下，常常将一些筛选出的数据作一些分类，而将数据分成若干集合，如将所有学生的成绩按学号加以分类，再对每一个集合进行统计分析。不使用group by所筛选出的数据也是以集合的形式存在，只是它们自成一个集合而非数个集合。要说明的是所筛选出的数据集合可能包含有多笔数据、一笔数据或无数据。常用的集总函数（专门为分析GROUP BY之后的每一个集合数据而设计的一些函数）有：（1）count()语法结构：count([all|distinct expression]|[*])功能：返回一个集合内所拥有的记录数参数说明：all：施用于所有的数值； distinct:返回唯一且非NULL数值的个数；*计算一个表格中所有记录的总笔数。①查询student表中有多少学生记录？select count(*) as 学生总数 from student②按照性别，分组统计男女人数各多少，并且按照性别降序排序select gender as 性别,count(*) as 人数 from student group by gender order by gender desc或者：select gender as 性别,count(*) as 人数 from student group by gender order by 性别 descselect gender as 性别,count(*) as 人数 from student group by gender order by 1 descorder by 排序的字段可以用表中原有的字段名，也可以使用as后的别名，还可以是要显示列的编号，如上面“性别”是要显示的第1列，排序时可以order by 1。③查询score表中有多少个不同的课号？select count(distinct course_no) as 数量 from score(2)SUM函数语法：sum([all|distinct]expression)功能：返回一个集合内所有数值或不同数值的总和，只能用于数字列，它会排除NULL参数说明：ALL：用于所有的数值；DISTINCT：表示SUM返回不同数值的总和；expression为一常数、列或函数①查询成绩表中，学生的总成绩select sum(score) as 总成绩 from score该语句将所有学生的成绩加在了一起。②根据“student_no”，分组小计每个学生的总成绩：select student_no as 学号,sum(score) as 总分 from score group by student_no（3）AVG函数语法：avg([all|distinct expression)功能：返回一个集合内所有数值或不同数值的平均值，它会排除NULL。①根据“student_no”，分组小计每个学生的平均成绩。select student_no as 学号,avg(score) as 平均分 from score group by student_no如果想四舍五入，保留两位小数，可以：select student_no as 学号, round(avg(score),2) as 平均分 from score group by student_no如果采用cast函数，则：select student_no as 学号, cast(avg(score) as decimal(10,2)) as 平均分 from score group by student_no②根据“student_no”，分组小计每个学生的平均成绩，列出平均分大于80的学生：select student_no as 学号,avg(score) as 平均分 from score group by student_no having avg(score)>80上边语句如果写作select student_no as学号,avg(score) as 平均分 from score group by student_no having 平均分>80，虽然在有的数据库管理系统中是正确的，但在SQL Server中是错误的。②相当于：相当于执行下边两条select语句的效果。select student_no as 学号,avg(score) as 平均分 into result from score group by student_no select * from result where 平均分>80但如果写作：select student_no as 学号,avg(score) as 平均分 from score where avg(score)>80 group by student_no 是错误的。对于分组后记录再进行筛选，要使用having，而不能使用where。Select语句中，只要有having，其前边必须有group by（4）max函数语法：max(expression)功能：返回一个集合内所有数值的最大值（5）min函数语法：min(expression)功能：返回一个集合内所有数值的最小值如：查询每一课程中的最高分和最低分：select course_no as 课号,max(score) as 最高分,min(score) as 最低分 from score group by course_no    多表查询（1）查询显示课程名、上课时间、上课地点、任课老师“课程名”、“上课时间”、“上课地点”来自course表，“任课老师”来自teacher表，course表与teacher表通过teacher_ID关联，查询语句为：select course.course_name as 课程名,course_address as 上课地点,course_time as 上课时间,teacher.teacher_name as 任课教师 from course,teacher where course.teacher_ID=teacher.teacher_ID该select语句中使用where指明了course和teacher两个表间的关联是内部关联。多表查询用的最多是内部关联。内部关系也可以采用下面语句查询，效果是一样的。select course.course_name as 课程名,course_address as 上课地点,course_time as 上课时间,teacher.teacher_name as 任课教师 from course inner join teacher on course.teacher_ID=teacher.teacher_ID将inner join 改换成left join或right join，上面的select语句就变成左关联或右关联查询了。如果要列出没有课程的老师的姓名，如何写？（2）查询学生的成绩，显示“学号”，“姓名”，“课程名”和“成绩”查询显示的4个字段来自于三个表：“学号”和“姓名”可来自student表中的student_no和student_name，“课程名”来自course表中的course_name，“成绩”来自score表中的score。student表与score表student_no相关联，course表与score表通过course_no关联。查询的语句为：select student.student_no as 学号,student_name as 姓名,course.course_name as 课程名,score.score as 成绩 from student,course,score where student.student_no= score.student_no and course.course_no=score.course_no同样该语句也可以写作：select student.student_no as 学号,student_name as 姓名,course.course_name as 课程名,score.score as 成绩 from student inner join score on student.student_no= score.student_no inner join course on course.course_no=score.course_no    增加记录（1）增加一条新记录insert into teacher(teacher_id,teacher_name,teacher_gender,teacher_phone) values('t4','刘甜甜','女','010-6875357')由于id字段设置的是自动增加，故不能通过代码为该字段赋值。增加单条记录的insert语句的格式：insert into 表名（字段1,字段2） values(值1，值2)（2）批量增加记录insert into 表名1（字段1,字段2） select 字段1,字段2 from 表名2 where 条件将表名2中符合条件的字段1，字段2的值，批量增加到表名1对应的字段中。使用时要注意表名2的字段必须与表名1的相一致，否则出现错误。    删除记录delete from 表名 where 删除条件如：delete from student where student_no='41321059'SQL语句可以相互嵌套。如果要删除student表中那些在score表中score<60的记录：delete from student where student_no in(select student_no from score where score<60)，语句执行时，首先通过select student_no from score where score<60从score表中找到不及格学生的student_no，然后从student表中删除这些student_no的记录。    更新记录update 表名 set 字段1=值1,字段2=值2 where 更新条件如：update score set score=score+5 where score<60，为不及格的同学加5分，如果要为女生加5分，需要使用SQL嵌套：update score set score=score+5 where student_no in(select student_no from student where gender='女')    操作表结构的SQL某些情况下，表的字段不是预先固定好的，需要通过程序动态生成和修改。（1）建立一个新表create table 工资(雇员号 char(8) not null,Primary Key(雇员号),工资日期 date,基本工资 decimal(8,2),岗位津贴 decimal(8,2),id int IDENTITY(1,1) NOT NULL)使用create创建了“工资”表，表的主键是“雇员号”，值不能为空；“id”整型，从1开始自动编号。（2）修改表结构增加字段：alter table 表名 add 字段名 数据类型删除字段：alter table 表名 drop 字段名给已经建立的“工资”表增加一列“所得税”： alter table 工资 add 所得税 decimal(6,2)（3）删除数据表drop table 表名将“工资”表删除：drop table 工资